#### 浏览器内核和JS引擎的关系

以`webkit`为例子，`webkit`事实上有两部分组成：

- `WebCore`:负责HTML解析、布局、渲染等等相关工作
- `JavaSCriptCore`:解析、执行JavaScript代码（v8就是一个强大的`JS`引擎)

v8引擎的工作原理：

![](./images/v8.webp)

#### v8对于`js`的解析流程

[Parse模块](https://v8.dev/blog/scanner)（解析器）:  模块会将JavaScript代码转换成AST（抽象语法树），这是因为解释器并不直接认识JavaScript代码； 

[Ignition](https://v8.dev/blog/ignition-interpreter)(解释器), 会将AST转换成ByteCode（字节码）, 同时会收集TurboFan优化所需要的信息（比如函数参数的类型信息，有了类型才能进行真实的运算) 同时会收集TurboFan优化所需要的信息（比如函数参数的类型信息，有了类型才能进行真实的运算)

[TurboFan](https://v8.dev/blog/turbofan-jit)是一个编译器，可以将字节码编译为CPU可以直接执行的机器码 

**如果一个函数被多次调用，那么就会被标记为热点函数，那么就会经过`TurboFan`转换成优化的机器码，提高代码的执行性能;**

所以以下代码会造成性能问题：

```js
function sum(num1, num2) {
    return num1+num2
}
for(let i = 1; i < 100; i++) {
    sum(1,2)
}
sum('a', 'c')// 造成优化失效
```

机器码实际上也会被还原为`ByteCode`，这是因为如果后续执行函数的过程中，类型发生了变化（比如sum函数原来执行的是 number类型，后来执行变成了string类型 。所以使用`ts`对于项目也起到了一定的优化

#### V8的执行细节

parse过程：

- Blink将源码交给V8引擎，Stream获取到源码并且进行编码转换；
- Scanner会进行词法分析，词法分析会将代码转化成tokens
- 接下来token会被转化成AST树，经过`Parser`和`PreParser`：
  - Parser就是直接将token转成AST树结构
  -  PreParser称之为预解析 , V8引擎就实现了Lazy Parsing（延迟解析）的方案，它的作用是将不必要的函数进行预解析，也就是只解析暂 时需要的内容，而对函数的全量解析是在函数被调用时才会进行.
  -  比如我们在一个函数outer内部定义了另外一个函数inner，那么inner函数就会进行预解析 

