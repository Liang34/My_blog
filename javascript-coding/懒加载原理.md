1.懒加载概念
对于页面有很多静态资源的情况下（比如网商购物页面），为了节省用户流量和提高页面性能，可以在用户浏览到当前资源的时候，再对资源进行请求和加载。

2.懒加载实现原理
2.1监听`onscroll`事件判断资源位置
首先为所有懒加载的静态资源添加自定义属性字段，比如如果是图片，可以指定`data-src`为真实的图片地址，`src`指向`loading`的图片。
然后当资源进入视口的时候，将`src`属性值替换成`data-src`的值。
可以使用元素的`getBoundingRect().top`判断是否在视口内，也可以使用元素距离文档顶部的距离`offsetTop`和`scrollTop`是否小于视口高度来判断：

```js
window.onload = function () {
  var clientHeight = getWindow().height;
  //选取所有包含属性data-src的img元素，然后在滚动的时候判断是否在可视区域
  var imgArray = toArray(document.querySelectorAll("[data-src]"));

  function lazyLoad() {
    var loadedIndex = [];
    var scrollTop = document.body.scrollTop || document.documentElement.scrollTop;
    for (let i = 0; i < imgArray.length; i++) {
      let img = imgArray[i];
      if (img.offsetTop - scrollTop < clientHeight) {
        img.src = img.getAttribute("data-src");
        console.log("img " + img.src.substring(img.src.lastIndexOf("/") + 1) + "display.");
        loadedIndex.unshift(i); //这里不能用push，因为删除的时候先要删除后面的，再删除前面的，否则Array删除了前面的，后面的就会自动覆盖到前面来。
      }
    }

    for (let i = 0; i < loadedIndex.length; i++) {
      imgArray.splice(loadedIndex[i], 1);
    }
  }

  //跨浏览器获取可视窗口大小
  function getWindow() {
    if (typeof window.innerWidth != 'undefined') {
      return {
        width: window.innerWidth,
        height: window.innerHeight
      }

    } else {
      return {
        width: document.documentElement.clientWidth,
        height: document.documentElement.clientHeight
      }
    }
  }

  function toArray(arrlike) {
    if (typeof Array.from != "function") {
      var result = [];
      for (let i = 0; i < arrlike.length; i++) {
        result.push(arrlike[i]);
      }
      return result;
    } else {
      return Array.from(arrlike);
    }
  }

  window.onscroll = lazyLoad;
  lazyLoad();
}
```
其中判断元素是否应该下载的语句是：

```js
if(img.offsetTop-scrollTop<clientHeight){
  img.src=img.getAttribute("data-src");
  console.log("img "+img.src.substring(img.src.lastIndexOf("/")+1)+"display.");
  loadedIndex.unshift(i);
}
```
或者是:`if(rect.top>=0&&rect.top<=clientHeight)`
但是由于scroll事件密集发生，计算量很大，容易造成性能问题，因此不推荐使用。
2.2 浏览器API——`IntersectionObserver`
可以自动”观察”元素是否可见，Chrome 51+ 已经支持。由于可见（visible）的本质是，目标元素与视口产生一个交叉区，所以这个 API 叫做”交叉观察器”。但是IE11目前仍不支持。

3.懒加载封装
利用`IntersectionObserver AP`I的插件：

```js
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Intersection</title>
</head>
<body>
  <h2>图片列表</h1>
    <ul>
      <li><img src="imgs/timg.gif" data-src="imgs/OIP.jpg" alt="" /></li>
      <li><img src="imgs/timg.gif" data-src="imgs/OIP (1).jpg" alt="" /></li>
      <li><img src="imgs/timg.gif" data-src="imgs/OIP (2).jpg" alt="" /></li>
      <li><img src="imgs/timg.gif" data-src="imgs/OIP (3).jpg" alt="" /></li>
      <li><img src="imgs/timg.gif" data-src="imgs/OIP (4).jpg" alt="" /></li>
      <li><img src="imgs/timg.gif" data-src="imgs/OIP.jpg" alt="" /></li>
      <li><img src="imgs/timg.gif" data-src="imgs/OIP (1).jpg" alt="" /></li>
      <li><img src="imgs/timg.gif" data-src="imgs/OIP (2).jpg" alt="" /></li>
      <li><img src="imgs/timg.gif" data-src="imgs/OIP (3).jpg" alt="" /></li>
      <li><img src="imgs/timg.gif" data-src="imgs/OIP (4).jpg" alt="" /></li>
    </ul>
</body>
<script>
    const root = document.getElementsByTagName('ul')[0]
    const options = {
          root: root,
// 这里是一个数组可以指定多个比例类似[0.25, 0.5, 0.75, 1]
          threshold: [0],//交会处
          rootMargin:"0px"//对视口进行收缩和扩张
      }
  const lazyIntersection = new IntersectionObserver(entires => {
  // entires为监听的节点数组对象
    entires.forEach((item,index) => {
      console.log(item)
      // console.log(item.target, item.isIntersecting? '可见': '不可见')
// isIntersecting是当前监听元素交叉区域是否在可视区域指定的阈值内返回的是一个布尔值
      if(item.isIntersecting) {
        console.log('可见')
        item.target.src = item.target.getAttribute('data-src')
    // 这里资源加载后就停止进行观察
        lazyIntersection.unobserve(item.target)
      }
      // console.log(item)
    })
  }, options)
 // doucument.getElementsByTagName()获取的是一个元素DOM节点的伪数组，无法进行数组的遍历
 // 我们可以使用Array.from()将伪数组转化为真数组进行数组操作
  let data = Array.from(document.getElementsByTagName('img'))
  data.forEach(item => {
// observe用来观察指定的DOM节点
     lazyIntersection.observe(item)
  })
</script>
<style>
  * {
    margin: 0;
    padding: 0;
  }
  ul {
    height: 1000px;
    overflow-y: scroll;
  }
  ul li {
    list-style: none;
    margin-bottom: 10px;
    text-align: center;
  }
  img {
    min-height: 900px;
  }
</style>
</html>
```

3.1使用`Jquery`插件`jquery_lazyload`

`Github`地址：https://github.com/tuupola/jquery_lazyload
引入CDN：

<script src="https://cdn.jsdelivr.net/npm/lazyload@2.0.0-beta.2/lazyload.js"></script>
    为需要懒加载的图片添加lazyload类名，指定data-src为真实图片地址，src为缩略图地址，调用lazyload()；
3.2阮一峰 lozad.js

https://github.com/ApoorvSaxena/lozad.js

可以引入模板使用，也可以直接使用CDN引入脚本文件：
CDN：

<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script>
1
使用方法之一，对所有需要懒加载的图片添加”lozad”类名，然后使用以下脚本调用：

```js
const observer = lozad(); // lazy loads elements with default selector as '.lozad'
observer.observe();
```

```
4.示例演示及三种方案源码
https://lucyzlu.github.io/Web/lazyload/lazyload.html
```

5.参考
`IntersectionObserver API `使用教程
阮一峰：网页性能管理详解
廖雪峰：使用jQuery实现图片懒加载原理