Tree-shaking

- 上下文未用到的代码（dead code)
- 基于ES6 import export

webapck4中使用production会启用：

原理：根据webpack的定义入口，入口作为根节点，查看其引用的模块，再进一步分析所引用的模块又引用了哪些东西，没用到的会shaking下去。最终打包只包含有用的代码。

全局作用域：

```js
// package.json中
"sideEffects": ["*.css"]
```

- 注意babel的影响：babel会将es6转为其他代码，如果把import转为低级语法会导致tree-shaking失效：

  - ```js
    module.exports = {
        presets: [
            [
                '@babel/preset-env',
                {
                    // 禁止转换模块化语法
                    modules: false,
                    // 目标函数复用：browserslist
                    "targets": {
                        "browsers": [">0.25%"]
                    },
                    // pollify按需引用
                    "useBuiltIns": "usage",
                    "bugfixes": true
                }
            ],
            '@babel/preset-react'
        ],
        plugins: [
            '@babel/plugin-proposal-class-properties',
            // 辅助函数复用
            "@babel/plugin-transform-runtime",
        ]
    };
    ```

JS压缩

- Webpack 4后引入`uglifyjs-webpack-plugin`
- 支持ES6替换`terser-webpack-plugin`
- 减少JS文件体积

作用域提升(production默认开启）：依赖合并，变得精简。

- 代码体积减少
- 提高执行效率
- 同样注意Babel的modules配置：同样需要import 与export语法

babel7优化配置：

- 在需要的地方使用pollify

  - ```js
    "useBuiltIns": "usage"
    ```



webpack依赖优化

noParse

- 提高构建速度
- 直接通知webpack忽略较大的库
- 被忽略的库不能有import,require,define的引入方式

```js
// 例如：loadsh
module: {
  noParse: /lodash/,
}
```

DLLPlugin(开发时使用)

- 避免打包时对不变的库重复构建
- 提高构建速度

基于webpack的代码拆分（code splitting）

- 把单个bundle文件拆分成若干小bundle/chunks
- 缩短首屏加载时间

splitChunks提取共有代码，拆分业务代码与第三方库

```js
// webpack.config.js
optimization: {
        splitChunks: {
            cacheGroups: {
                // 拆分第三方代码
                vendor: {
                    name: 'vendor',
                    test: /[\\/]node_modules[\\/]/,
                    minSize: 0,
                    minChunks: 1,
                    priority: 10,
                    chunks: 'initial'// 同步加载，静态加载
                },
                common: {
                    name: 'common',
                    test: /[\\/]src[\\/]/,
                    chunks: 'all',
                    minSize: 0,
                    minChunks: 2
                }
            }
        }
    }
```

- 动态加载(异步加载)

```js
// react
lazy+Suspense
// webpack
import('./math').then()
```

基于webpack的资源压缩(minification)

- Terser压缩JS

- mini-css-extract-plugin(css提取）、optimize-css-assets-webpack-plugin压缩CSS

  - ```js
    new MiniCssExtractPlugin({
                filename: '[name].[contenthash].css',
                chunkFilename: '[id].[contenthash:8].css',
            }),
            new OptimizeCssAssetsPlugin({
                cssProcessorPluginOptions: {
                    preset: ['default', {discardComments: {removeAll: true}}],
                },
                canPrint: true
            })
    ```

- HtmlWebpackPlugin-minify压缩HTML

基于webpack的资源持久化缓存

持久化缓存方案

- 每个打包的资源文件有唯一的hash值
- 修改后只有受影响的文件hash变化
- 充分利用浏览器缓存

监测与分析：

- [stats分析与可视化图](https://alexkuz.github.io/webpack-chart/)
  - 运行webpack --profile --json > stats.json获取json文件到该网站查看可视化
- webpack-bundle-analyzer进行体积分析
- speed-measure-webpack-plugin速度分析

安装"source-map-explorer",基于source-map：

```js
// webpack.config.js
devtool: 'hidden-source-map',
```

在package.json中：

```js
"analyze": "source-map-explorer 'build/*.js'"
```

React按需加载

React router基于webpack动态引入

使用loadable高级组件

```js
import loadable from '@loadable/component';
// 使用React-Loadable动态加载组件
const LoadableAbout = loadable(() => import('./About.jsx'), {
    fallback: '<div>loading...</div>'
})
```



