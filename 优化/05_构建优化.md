Tree-shaking

- 上下文未用到的代码（dead code)
- 基于ES6 import export

webapck4中使用production会启用：

原理：根据webpack的定义入口，入口作为根节点，查看其引用的模块，再进一步分析所引用的模块又引用了哪些东西，没用到的会shaking下去。最终打包只包含有用的代码。

全局作用域：

```js
// package.json中
"sideEffects": ["*.css"]
```

- 注意babel的影响：babel会将es6转为其他代码，如果把import转为低级语法会导致tree-shaking失效：

  - ```js
    module.exports = {
        presets: [
            [
                '@babel/preset-env',
                {
                    // 禁止转换模块化语法
                    modules: false,
                    // 目标函数复用：browserslist
                    "targets": {
                        "browsers": [">0.25%"]
                    },
                    // pollify按需引用
                    "useBuiltIns": "usage",
                    "bugfixes": true
                }
            ],
            '@babel/preset-react'
        ],
        plugins: [
            '@babel/plugin-proposal-class-properties',
            // 辅助函数复用
            "@babel/plugin-transform-runtime",
        ]
    };
    ```

JS压缩

- Webpack 4后引入`uglifyjs-webpack-plugin`
- 支持ES6替换`terser-webpack-plugin`
- 减少JS文件体积

作用域提升(production默认开启）：依赖合并，变得精简。

- 代码体积减少
- 提高执行效率
- 同样注意Babel的modules配置：同样需要import 与export语法

babel7优化配置：

- 在需要的地方使用pollify

  - ```js
    "useBuiltIns": "usage"
    ```



webpack依赖优化

noParse

- 提高构建速度
- 直接通知webpack忽略较大的库
- 被忽略的库不能有import,require,define的引入方式

```js
// 例如：loadsh
module: {
  noParse: /lodash/,
}
```

DLLPlugin(开发时使用)

- 避免打包时对不变的库重复构建
- 提高构建速度

基于webpack的代码拆分（code splitting）

- 把单个bundle文件拆分成若干小bundle/chunks
- 缩短首屏加载时间

splitChunks提取共有代码，拆分业务代码与第三方库

```js

```



