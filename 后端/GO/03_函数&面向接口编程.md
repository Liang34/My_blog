函数定义：

```go
// 函数定义。a,b是形参， d传地址, c 返回值
func add(a int, b int, d *int) (c int) {
	a = a + b
	*d = 888
	return a
}

func main() {
	var x, y, z int = 1, 2, 3
	fmt.Println(add(x, y, &z))// 3
	fmt.Println(x, y, z)// 1 2 888
}
```

slice、map、channel都是引用类型，它们作为函数参数时其实跟普通struct没什么区别，都是对struct内部的各个字段做一次拷贝传到函数内部。

```go
package main

import "fmt"

func slice_arg_1(arr []int) { //slice作为参数，实际上是把slice的arrayPointer、len、cap拷贝了一份传进来
	arr[0] = 1           //修改底层数据里的首元素
	arr = append(arr, 1) //arr的len和cap发生了变化，不会影响实参
}

func main() {
	arr := []int{8}
	slice_arg_1(arr)
	fmt.Println(arr[0])   //1
	fmt.Println(len(arr)) //1
}
```

### 闭包：

```go
// 闭包（Closure）是引用了自由变量的函数。自由变量将和函数一同存在，即使已经离开了创造它的环境。
func sub() func() {
	i := 10
	fmt.Printf("%p\n", &i)
	b := func() {
		fmt.Printf("i addr %p\n", &i) //闭包复制的是原对象的指针
		i--                           //b函数内部引用了变量i
		fmt.Println(i)
	}
	return b //返回了b函数，变量i和b函数将一起存在，即使已经离开函数sub()
}

// 外部引用函数参数局部变量
func add(base int) func(int) int {
	return func(i int) int {
		fmt.Printf("base addr %p\n", &base)
		base += i
		return base
	}
}

func main() {
	b := sub() // 0xa09a058
	b()        // i addr 0xa09a058  9
	b()        // i addr 0xa09a058  8

	tmp1 := add(10)
	fmt.Println(tmp1(1), tmp1(2)) //11,13
	// 此时tmp1和tmp2不是一个实体了
	tmp2 := add(100)
	fmt.Println(tmp2(1), tmp2(2)) //101,103
}

```

### 延迟调用defer

* defer用于注册一个延迟调用（在函数返回之前调用）。

- defer典型的应用场景是释放资源，比如关闭文件句柄，释放数据库连接等。
- 如果同一个函数里有多个defer，则后注册的先执行。
- defer后可以跟一个func，func内部如果发生panic，会把panic暂时搁置，当把其他defer执行完之后再来执行这个。
- defer后不是跟func，而直接跟一条执行语句，则相关变量在注册defer时被拷贝或计算。

```go
func basic() {
    fmt.Println("A")
    defer fmt.Println(1) fmt.Println("B")
    //如果同一个函数里有多个defer，则后注册的先执行
    defer fmt.Println(2)
    fmt.Println("C")
}
func defer_exe_time() (i int) {
	i = 9
	defer func() { //defer后可以跟一个func
		fmt.Printf("first i=%d\n", i) //打印5，而非9。充分理解“defer在函数返回前执行”的含义，不是在“return语句前执行defer”
	}()
	defer func(i int) {
		fmt.Printf("second i=%d\n", i) //打印9
	}(i)
	defer fmt.Printf("third i=%d\n", i) //defer后不是跟func，而直接跟一条执行语句，则相关变量在注册defer时被拷贝或计算
	return 5
}
```

### 异常处理：

go语言没有try catch，它提倡返回error。

```go
func divide(a, b int) (int, error) {
    if b == 0 {
        return -1, errors.New("divide by zero")
    }
    return a / b, nil
}
if res, err := divide(3, 0); err != nil {//函数调用方判断error是否为nil
    fmt.Println(err.Error())
}
```

### 接口定义：

```go
type Transporter interface {
  // 接口只定义方法，不定义变量
  move(src string, dest string)(int error) // 方法名（参数列表) 返回值列表
  whistle(int) int // 参数列表和返回值列表里的变量名可以省略
}
```
