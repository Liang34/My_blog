## JavaScript柯里化

 JavaScript柯里化是把接收多个参数的函数，变成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参 数，而且返回结果的新函数的技术；

简言之： 只传递给函数一部分参数来调用它，让它返回一个函数去处理剩余的参数 ;

##### 柯里化的结构：

```js
// 未柯里化
function add(x, y, z) {
  return x + y + z
}
// 柯里化
var sum2 = x => y => z => {
  return x + y + z
}
```

##### 为什么需要柯里化：

 在函数式编程中，我们其实往往希望**一个函数处理的问题尽可能的单一**，而不**是将一大堆的处理过程交给一个 函数来处理；**

 那么**我们是否就可以将每次传入的参数在单一的函数中进行处理**，处理完后在**下一个函数中再使用处理后的结 果；**

 另外一个使用柯里化的场景是可以帮助我们可以**复用参数逻辑**。

将函数自动转为柯里化函数。

```js
// 柯里化函数的实现hyCurrying
function hyCurrying(fn) {
  function curried(...args) {
    // 判断当前已经接收的参数的个数, 可以参数本身需要接受的参数是否已经一致了
    // 1.当已经传入的参数 大于等于 需要的参数时, 就执行函数
    if (args.length >= fn.length) {
      // fn(...args)
      // fn.call(this, ...args)
      return fn.apply(this, args)
    } else {
      // 没有达到个数时, 需要返回一个新的函数, 继续来接收的参数
      function curried2(...args2) {
        // 接收到参数后, 需要递归调用curried来检查函数的个数是否达到
        return curried.apply(this, args.concat(args2))
      }
      return curried2
    }
  }
  return curried
}
```

1、实现：

sum(1, 2, 3).sumOf(); //6
sum(2, 3)(2).sumOf(); //7
sum(1)(2)(3)(4).sumOf(); //10
sum(2)(4, 1)(2).sumOf(); //9

```js
function sum(...args) {
    const arg = [...args]

    count = function(...args) {
        arg.push(...args)
        return count
    }
    count.sumOf = function() {
        return arg.reduce((a, b) => a + b)
    }
    return count
}
```

2、实现

```
add(1, 2, 3); // 6
add(1, 2)(3);// 6
add(1)(2, 3); // 6
```

```js
function add(...args) {
  if(args.length === 3) {
      return args.reduce((pre,cur)=>pre+cur)
  }
  return function(...args2){
	args = args.concat(args2)
    if(args.length === 3) {
        return args.reduce((pre,cur)=>pre+cur)
    }
  }
}
```

另一种思路：

````js
const curry = (fn, ...args) => 
    // 函数的参数个数可以直接通过函数数的.length属性来访问
    args.length >= fn.length // 这个判断很关键！！！
    // 传入的参数大于等于原始函数fn的参数个数，则直接执行该函数
    ? fn(...args)
    /**
     * 传入的参数小于原始函数fn的参数个数时
     * 则继续对当前函数进行柯里化，返回一个接受所有参数（当前参数和剩余参数） 的函数
    */
    : (..._args) => curry(fn, ...args, ..._args);

function add1(x, y, z) {
    return x + y + z;
}
const add = curry(add1);
console.log(add(1, 2, 3));
console.log(add(1)(2)(3));
console.log(add(1, 2)(3));
console.log(add(1)(2, 3));
````

3、curry函数

```js

// 假设有以下三个函数
// a()
// b()
// c()

// 实现 compose 函数，使得
// compose([a, b, c])(args) = a(b(c(args)))
```

```js
const compose = (fns) => {
  return function (args) {
     return  fns.reverse().reduce( async (prev, cur)=> {
         return await cur(prev)
     }, args)
  }
}
```
