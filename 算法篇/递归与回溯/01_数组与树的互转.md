## 数组转树结构

### 题目描述：

```js
// 用 JS 写一个函数，将扁平化的数据转化为树形结构的数据
// 输入：（顺序不定，id 是个随机值，下面的例子是为了方便展示）
const a = [ 
  { id: 'R1', parentId: null }, 
  { id: 'R2', parentId: null }, 
  { id: 'R1-1', parentId: 'R1' }, 
  { id: 'R1-2', parentId: 'R1' }, 
  { id: 'R1-3', parentId: 'R1' }, 
  { id: 'R2-1', parentId: 'R2' }, 
  { id: 'R2-2', parentId: 'R2' }, 
  { id: 'R1-1-1', parentId: 'R1-3' } 
]
// 输出
[ 
  { 
    id: 'R1', 
    parentId: null, 
    children: [ 
      { id: 'R1-1', parentId: 'R1' }, 
      { id: 'R1-2', parentId: 'R1' }, 
      { 
        id: 'R1-3', 
        parentId: 'R1', 
        children: [ 
          { id: 'R1-1-1', parentId: 'R1-3' } 
        ] 
      } 
    ] 
  }, 
  { 
    id: 'R2', 
    parentId: null, 
    children: [ 
      { id: 'R2-1', parentId: 'R2' }, 
      { id: 'R2-2', parentId: 'R2' } 
    ] 
  } 
] 
```

### 思路

实现一个递归函数，在每次递归中都去找改child的parent即可

```js
const toTree = (arr) => {
  const res = []
  const recursion = (resData, parentId) => {
    for(let item of arr) {
      if(item.parentId === parentId) {
        const newItem = {...item, children: []}
        resData.push(newItem)
        // 继续递归找子孩子
        recursion(newItem.children, newItem.id)
      }
    }
  }
  recursion(res, null)
  return res
}
```

## 树结构转扁平化

#### 题目描述

```js
// 用 JS 写一个函数，将树形结构的数据转化为扁平化的数据
// 输入：（顺序不定，id 是个随机值，下面的例子是为了方便展示）
[ 
  { 
    id: 'R1', 
    parentId: null, 
    children: [ 
      { id: 'R1-1', parentId: 'R1' }, 
      { id: 'R1-2', parentId: 'R1' }, 
      { 
        id: 'R1-3', 
        parentId: 'R1', 
        children: [ 
          { id: 'R1-1-1', parentId: 'R1-3' } 
        ] 
      } 
    ] 
  }, 
  { 
    id: 'R2', 
    parentId: null, 
    children: [ 
      { id: 'R2-1', parentId: 'R2' }, 
      { id: 'R2-2', parentId: 'R2' } 
    ] 
  } 
] 
// 输出
const a = [ 
  { id: 'R1', parentId: null }, 
  { id: 'R2', parentId: null }, 
  { id: 'R1-1', parentId: 'R1' }, 
  { id: 'R1-2', parentId: 'R1' }, 
  { id: 'R1-3', parentId: 'R1' }, 
  { id: 'R2-1', parentId: 'R2' }, 
  { id: 'R2-2', parentId: 'R2' }, 
  { id: 'R1-1-1', parentId: 'R1-3' } 
]

```

#### 实现思路：

用广度优先遍历的思想即可，想把第一层节点放到结果数组中，然后再把他的子节点放到队列中，

然后查看队列中是否还有其他元素，再出队即可

```js
const treeToArray = (arr) => {
  const queue = [...arr], res = []
  while(queue.length) {
    const node = queue.shift()
    res.push({ id: node.id, parentId: node.id })
    if(node.children) {
      node.children.forEach(element => {
        queue.push(element)
      });
    }
  }
  return res
}
```

那如果没有parentId呢？

直接用map记录，在子元素入队的时候做好记录其parentId即可

```js
const treeToArray = (arr) => {
  const queue = [...arr], res = []
  // 用map记录对应的id
  const map = new Map();
  while(queue.length) {
    const node = queue.shift()
    res.push({ id: node.id, parentId: map.get(node.id) || null })
    if(node.children) {
      node.children.forEach(element => {
        map.set(element.id, node.id)
        queue.push(element)
      });
    }
  }
  return res
}
```
