#### [ 压缩字符串](https://leetcode-cn.com/problems/string-compression/)

给定一组字符，使用[原地算法](https://baike.baidu.com/item/原地算法)将其压缩。

压缩后的长度必须始终小于或等于原数组长度。

数组的每个元素应该是长度为1 的**字符**（不是 `int `整数类型）。

在完成[原地](https://baike.baidu.com/item/原地算法)**修改输入数组**后，返回数组的新长度。

**进阶：**
你能否仅使用O(1) 空间解决问题？

**示例 1：**

```
输入：
["a","a","b","b","c","c","c"]

输出：
返回 6 ，输入数组的前 6 个字符应该是：["a","2","b","2","c","3"]

说明：
"aa" 被 "a2" 替代。"bb" 被 "b2" 替代。"ccc" 被 "c3" 替代。
```

思路：

- 数组的每个元素应该是长度为1 的字符（不是 `int `整数类型）

-  意思就是 如果 b12 的话是这样: ['b', '1', '2'], 而不是['b', '12']
- 思路就是:
-  循环chars, 每次把头部删了, 用个k记录字符, j记录字符出现的次数,
- 一旦k和头部元素不同,就把该字符和次数放到数组尾部, 重置k和j
-  循环结束后, 最后的字符没记录要加上

```js
var compress = function(chars) {
  let k = chars[0]
  let len = chars.length
  let i = 0, j = 0
  while(len){
    if(k !== chars[0]){
      chars.push(k)
      if (j > 1) chars.push(...(j + ''))
      j = 0
      k = chars[0]
    }
    chars.shift()
    j++
    len--
  }
  // 加上最后的字符
  chars.push(k)
  if (j > 1) chars.push(...(j + ''))
  return chars.length
};
```

