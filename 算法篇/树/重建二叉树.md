#### [根据前序和后序遍历构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-postorder-traversal/)

返回与给定的前序和后序遍历匹配的任何二叉树。

 `pre` 和 `post` 遍历中的值是不同的正整数。

**示例：**

```
输入：pre = [1,2,4,5,3,6,7], post = [4,5,2,6,7,3,1]
输出：[1,2,3,4,5,6,7]
```

**提示：**

- `1 <= pre.length == post.length <= 30`
- `pre[]` 和 `post[]` 都是 `1, 2, ..., pre.length` 的排列
- 每个输入保证至少有一个答案。如果有多个答案，可以返回其中一个。

思路：对于这道题我们可以通过先在草稿纸上先画一个简单的二叉树来对比先续和后续的数组区别，感觉和其他的生成二叉树唯一的差别就是当次通过根节点无法判断左右树
因为先序遍历根节点，后续遍历根节点一个在最前面 一个在最后面， 对数组没有划分作用。这样我们就想出在当次知道根节点后，根据下个根节点（左子树根节点）的
序号来划分左右树。如图：

![image.png](http://120.25.239.32:8090/upload/2021/09/image-c42d07bdc1264ef08d742a8ee27db57c.png)

实现代码：

```js
var constructFromPrePost = function(preorder, postorder) {
  if(!preorder.length) return null
  const root = new TreeNode(preorder.shift())
  postorder.pop()
  if(postorder.length){
      const temp = postorder.indexOf(preorder[0])
      root.left = constructFromPrePost(preorder.slice(0, temp + 1),postorder.slice(0, temp+1))
      root.right = constructFromPrePost( preorder.slice(temp+1), postorder.slice(temp+1))
  }
  return root
};
```

#### [105. 从前序与中序遍历序列构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)

难度中等1221收藏分享切换为英文接收动态反馈

给定一棵树的前序遍历 `preorder` 与中序遍历 `inorder`。请构造二叉树并返回其根节点。

 

**示例 1:**

![img](https://assets.leetcode.com/uploads/2021/02/19/tree.jpg)

```
Input: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]
Output: [3,9,20,null,null,15,7]
```

**示例 2:**

```
Input: preorder = [-1], inorder = [-1]
Output: [-1]
```

 ```js
var buildTree = function(preorder, inorder) {
  if(!preorder.length) return null
  let root = new TreeNode(preorder[0])
  let idx = inorder.indexOf(preorder[0])
  root.left = buildTree(preorder.slice(1, idx+1), inorder.slice(0, idx))
  root.right = buildTree(preorder.slice(idx+1), inorder.slice(idx+1))
  return root
};
 ```

