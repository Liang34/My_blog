#### [104. 二叉树的最大深度](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/)

难度简单971收藏分享切换为英文接收动态反馈

给定一个二叉树，找出其最大深度。

二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。

**说明:** 叶子节点是指没有子节点的节点。

**示例：**
给定二叉树 `[3,9,20,null,null,15,7]`，

```
    3
   / \
  9  20
    /  \
   15   7
```

返回它的最大深度 3 。

代码：

```js
// dfs
var maxDepth = function(root) {
  if(!root) return 0
  let left = maxDepth(root.left)// 左边的深度
  let right = maxDepth(root.right)// 右边的深度
  return Math.max(left, right)+1
};
```

也可以使用`bfs`的做法:借助队列完成，参考层次遍历模板

```js
const maxDepth = function(root) {
  if(!root) return 0
  let res = 0// 统计层数
  const queue = [root]
  while(queue.length) {
    let len = queue.length
    while(len--) {
      const node = queue.shift()
      if(node.left) queue.push(node.left)
      if(node.right) queue.push(node.right)
    }
    res++
  }
  return res
}
```



#### [111. 二叉树的最小深度](https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/)

难度简单592收藏分享切换为英文接收动态反馈

给定一个二叉树，找出其最小深度。

最小深度是从根节点到最近叶子节点的最短路径上的节点数量。

**说明：**叶子节点是指没有子节点的节点。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2020/10/12/ex_depth.jpg)

```
输入：root = [3,9,20,null,null,15,7]
输出：2
```

注意：是叶子节点

```js
var minDepth = function(root) {
// 错误做法
// 输入：root = [2,null,3,null,4,null,5,null,6]
// 输出：5
//   if(!root) return 0
//   let leftDep = minDepth(root.left)
//   let rightDep = minDepth(root.right)
//   return Math.min(leftDep, rightDep) + 1
  if(!root) return 0
  if(!root.left && root.right){// 当左边为空的时候计算右边
    return 1 + minDepth(root.right)
  }
  if(root.left && !root.right){
      return 1+ minDepth(root.left)
  }
  return Math.min(minDepth(root.left), minDepth(root.right))+1
};
```

`bfs`做法：直接判断当`node.left && node.right`均为空即说明为叶子节点

```js
var minDepth = function(root) {
  if(!root) return 0
  const queue = [root]
  let res = 0
  while(queue.length) {
    let len = queue.length
    res++
    while(len--) {
      const node = queue.shift()
      if(node.left) queue.push(node.left)
      if(node.right) queue.push(node.right)
      if(!node.left && !node.right) return res
    }
  }
  return res
};
```

#### [N 叉树的最大深度](https://leetcode-cn.com/problems/maximum-depth-of-n-ary-tree/)

给定一个 N 叉树，找到其最大深度。

最大深度是指从根节点到最远叶子节点的最长路径上的节点总数。

N 叉树输入按层序遍历序列化表示，每组子节点由空值分隔（请参见示例）。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2018/10/12/narytreeexample.png)

```
输入：root = [1,null,3,2,4,null,5,6]
输出：3
```

**提示：**

- 树的深度不会超过 `1000` 。
- 树的节点数目位于 `[0, 104]` 之间。

思路：采用深度优先算法，递归计算除根节点外，每个子节点 node 的最大高度` max = Math.max(max, childNodeDepth)`，最后返回最大高度 max + 1 即可， 加 1 是加上根节点 root 的高度。

实现代码：`dfs`方法

```js
/**
 * // Definition for a Node.
 * function Node(val,children) {
 *    this.val = val;
 *    this.children = children;
 * };
 */
var maxDepth = function(root) {
  if(!root) return 0
  if(root.children.length === 0) return 1
  let children = root.children
  let max = 0
  for(let child of children) {
      let childDep = maxDepth(child)
      max = Math.max(max, childDep)
  }
  return max+1
}
```

 解法二：层序遍历，遍历一层 level 加 1，记录总共有多少层 

代码：

```js
var maxDepth = function(root) {
    if (root === null) {
        return 0
    } 
    let queue = [root];
    let level = 0;
    while(queue.length) {
        let len = queue.length; // 这时候的 len 表示当前一层所拥有的节点数
        while(len-- ) {
            let node = queue.shift(); // 按顺序推出节点，知道没有为止则到了下一层
            if (node.children.length > 0) {
                queue = queue.concat(node.children) // 将该节点的所有子节点推入栈中，也可以采用遍历，但更费时
            }
        }
        level++; // 层次加一
    }
    return level;
};
```

