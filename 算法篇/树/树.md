## 概览：

 树是用来模拟具有树状结构性质的数据集合。根据它的特性可以分为非常多的种类，对于我们来讲，掌握二叉树这种结构就足够了，它也是树最简单、应用最广泛的种类。 

对于二叉树的考察主要有以下几种方式：

### 二叉树的遍历：（递归版本与非递归版本）

- [二叉树的前序遍历](https://github.com/Liang34/My_blog/issues/3)
- [二叉树的中序遍历](https://github.com/Liang34/My_blog/issues/4)
- [二叉树的后序遍历](https://github.com/Liang34/My_blog/issues/5)
- [二叉树的层次遍历](https://github.com/Liang34/My_blog/issues/6)

根据前序遍历和中序遍历重建二叉树

- ​	重建二叉树

二叉树的对称性

- 对称二叉树
- 二叉树的镜像

#### [剑指 Offer 32 - III. 从上到下打印二叉树 III](https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/)

难度中等88收藏分享切换为英文接收动态反馈

请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。

 

例如:
给定二叉树: `[3,9,20,null,null,15,7]`,

```
    3
   / \
  9  20
    /  \
   15   7
```

返回其层次遍历结果：

```
[
  [3],
  [20,9],
  [15,7]
]
```

 

**提示：**

1. `节点总数 <= 1000`

思路：广度优先遍历，在每次遍历的时候先判断当前是奇数层还是偶数层，如果是奇数层就直接按队列的方式进栈即可，如果是偶数层则直接用`unshift`推进即可

代码：

```js
var levelOrder = function(root) {
  const res = []
  if(!root) return []
  let queue = [root], dir = 1
  while(queue.length>0) {
    let len = queue.length
    const temp = []
    while(len--) {
      const node = queue.shift()
      if(dir % 2 === 1) {
        temp.push(node.val)
      } else {
        temp.unshift(node.val)
      }
      if(node.left) queue.push(node.left)
      if(node.right) queue.push(node.right)
    }
    dir++
    res.push(temp)
  }
  return res
};
```

#### [199. 二叉树的右视图](https://leetcode-cn.com/problems/binary-tree-right-side-view/)

给定一棵二叉树，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。

**示例:**

```
输入: [1,2,3,null,5,null,4]
输出: [1, 3, 4]
解释:

   1            <---
 /   \
2     3         <---
 \     \
  5     4       <---
```

思路：深度优先遍历。记录当前的`step`数，只有在数组的长度等于`step`数才能插进数组，这样在同层级的左子树就无法插进数组了，因为先遍历的右子树能改变数组的长度。

实现代码:

```js
var rightSideView = function(root) {
  if(!root) return []
  let res = []
  // 通过res的动态长度决定是否要插入左子树
  const dfs = (node, step, res)=> {
    if(node) {
      if(res.length === step) {
        res.push(node.val)
      }
      dfs(node.right, step+1, res)
      dfs(node.left, step+1, res)
    }
  }
  dfs(root, 0, res)
  return res
}
```

思路二：
层次遍历，每次遍历到该层的最后一个节点就`push`进数组

```js
var rightSideView = function(root) {
  if(!root) return []
  const queue = [root]
  const res = []
  while(queue.length) {
    let len = queue.length
    while(len) {
      const node = queue.shift()
      if(len === 1) res.push(node.val)
      if(node.left) queue.push(node.left)
      if(node.right) queue.push(node.right)
      len--
    }
  }
  return res
}
```

