### 二分查找：

 [力扣题目链接](https://leetcode-cn.com/problems/binary-search/) 

给定一个 n 个元素有序的（升序）整型数组 `nums `和一个目标值` target`  ，写一个函数搜索 `nums `中的 `target`，如果目标值存在返回下标，否则返回 -1。

```js
输入: nums = [-1,0,3,5,9,12], target = 9
输出: 4
解释: 9 出现在 nums 中并且下标为 4
```

提示：

- 你可以假设 `nums `中的所有元素是不重复的。
- n 将在 [1, 10000]之间。
- `nums `的每个元素都将在 [-9999, 9999]之间。

分析： 首先是**有序**数组， 并且数组是**不重复**的，于是很容易想到二分法，但是要注意二分法的边界条件。 例如到底是 `while(left < right)` 还是 `while(left <= right)`，到底是`right = middle`呢，还是要`right = middle - 1`呢？ 

二分法经常写乱，主要是因为**对区间的定义没有想清楚，区间的定义就是不变量**。要在二分查找的过程中，保持不变量，就是在while寻找中每一次边界的处理都要坚持根据区间的定义来操作，这就是**循环不变量**规则。

写二分法，区间的定义一般为两种，左闭右闭即[left, right]，或者左闭右开即[left, right)。 

左闭右闭:[left, right]

- while (left <= right) 要使用 <= ，因为left == right是有意义的，所以使用 <=
- if (nums[middle] > target) right 要赋值为 middle - 1，因为当前这个nums[middle]一定不是target，那么接下来要查找的左区间结束下标位置就是 middle - 1

代码：

```js
var search = function(nums, target) {
  let left = 0, right = nums.length - 1
  while(left <= right) {
    let middle = left + Math.floor((right - left) / 2)
    if(nums[middle] > target) {
      right = middle - 1 // 其实就是选了区间[left, right],必须保证其值都是有效的
    } else if(nums[middle] < target) {
      left = middle + 1
    } else {
      return middle
    }
  }
  return -1
};
```

左闭右开写法： [left, right) 

- while (left < right)，这里使用 < ,因为left == right在区间[left, right)是没有意义的
- `if (nums[middle] > target) right `更新为 `middle`，因为当前`nums[middle]`不等于target，去左区间继续寻找，而寻找区间是左闭右开区间，所以right更新为middle，即：下一个查询区间不会去比较`nums[middle]`

```js
var search = function(nums, target) {
  let left = 0, right = nums.length
  while(left < right) {
    const middle = left + Math.floor((right - left)/2)
    if(nums[middle] > target) {
      right = middle
    } else if(nums[middle] < target) {
      left = middle + 1
    } else {
      return middle
    }
  }
  return -1
};
```



