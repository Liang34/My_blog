## 渲染流程

渲染流程的大致顺序，流水线可分为如下几个子阶段：**构建DOM树、样式计算、布局阶段、分层、绘制、分块、光栅化和合成。**

- 构建DOM树：将HTML转换为浏览器能够理解的结构——DOM树
- 样式计算：算出DOM节点中每个元素的具体样式，这个阶段大体可分为三步来完成。
  - 把CSS转换为浏览器能够理解的结构，**当渲染引擎接收到CSS文本时，会执行一个转换操作，将CSS文本转换为浏览器可以理解的结构——`styleSheets`。**
  - 转换样式表中的属性值，使其标准化，即：`em `-- > `px`, `red `-->`rgb(255, 0, 0)`
  - 计算出DOM树中每个节点的具体样式
- 布局阶段：计算出DOM树中可见元素的几何位置。分为两个阶段：创建布局树和布局计算。
  - 创建布局树
    - 遍历DOM树中的所有可见节点，并把这些节点加到布局树中；
      而不可见的节点会被布局树忽略掉，如head标签下面的全部内容，再比如`body.p.span`这个元素，因为它的属性包含 `dispaly:none`，所以这个元素也没有被包进布局树。
  - 布局计算
- 对布局树进行分层，并生成**分层树。**
  - 浏览器的页面实际被分成了很多层，这些图层叠加后合成了最终的页面。
  - 并不是布局树的每个节点都包含一个图层，如果一个节点没有对应的图层，那么这个节点就丛属于父节点的图层。
- 为每个图层生成**绘制列表**，并将其提交到合成线程。
- 合成线程将图层分成**图块**，并在**光栅化线程池**中将图块转换成位图
- 合成线程发送绘制图块命令`DrawQuad`给浏览器进程。
- 浏览器进程根据`DrawQuad`消息**生成页面**，并显示到显示器上。

## Load事件和`DOMContentLoaded`

- 当 `DOMContentLoaded `事件触发时，仅当DOM加载完成，不包括样式表，图片。

(譬如如果有`async`加载的脚本就不一定完成)

- 当 onload 事件触发时，页面上所有的DOM，样式表，脚本，图片都已经加载完成了。

（渲染完毕了）

所以，顺序是：`DOMContentLoaded -> load`

## CSS加载是否会阻塞DOM树渲染

这里说的是头部引入`css`的情况

首先，我们都知道：**`css`是由单独的下载线程异步下载的。**

然后再说下几个现象：

- `css`加载不会阻塞DOM树解析（异步加载时DOM照常构建）
- 但会阻塞render树渲染（渲染时需等`css`加载完毕，因为render树需要`css`信息）

## JS的加载是否会阻塞

默认情况下`js`的脚本执行是同步和阻塞的，但是 <script> 标签有` defer` 和 `async` 属性, 这可以改变脚本的执行方式，这些都是布尔类型了，没有值，只需要出现在 <script> 标签里即可。

**defer** 属性标注的脚本是延迟脚本，使得浏览器延迟脚本的执行，也就是说，脚本会被异步下载但是不会被执行，直到文档的载入和解析完成，并可以操作，脚本才会被执行。

**async** 属性标注的脚本是异步脚本，即异步下载脚本时，不会阻塞文档解析，但是一旦下载完成后，立即执行，阻塞文档解析。

**延迟脚本**会按他们在文档里的出现顺序执行

**异步脚本**在它们载入后执行，但是不能保证执行顺序。

使用`async`的意义就在于使得下载脚本时，不会阻塞文档的解析。因为`async`的脚本执行顺序是没有保证的，因此要确认脚本间没有依赖关系。

## 相关概念

相关概念有了上面介绍渲染流水线的基础，我们再来看看三个和渲染流水线相关的概念——“**重排”“重绘”和“合成**”。

理解了这三个概念对于你后续Web的性能优化会有很大帮助。

1、更新了元素的几何属性（重排）

更新元素的几何属性从上图可以看出，如果你通过JavaScript或者CSS修改元素的几何位置属性，例如改变元素的宽度、高度等，那么浏览器会触发重新布局，解析之后的一系列子阶段，这个过程就叫重排。无疑，重排需要更新完整的渲染流水线，所以开销也是最大的。

2、更新元素的绘制属性（重绘）接下来，我们再来看看重绘，比如通过JavaScript更改某些元素的背景颜色，渲染流水线会怎样调整呢？

更新元素背景从图中可以看出，如果修改了元素的背景颜色，那么布局阶段将不会被执行，因为并没有引起几何位置的变换，所以就直接进入了绘制阶段，然后执行之后的一系列子阶段，这个过程就叫重绘。相较于重排操作，重绘省去了布局和分层阶段，所以执行效率会比重排操作要高一些。

3、直接合成阶段那如果你更改一个既不要布局也不要绘制的属性，会发生什么变化呢？渲染引擎将跳过布局和绘制，只执行后续的合成操作，我们把这个过程叫做合成。

避开重排和重绘在上图中，我们使用了CSS的transform来实现动画效果，这可以避开重排和重绘阶段，直接在非主线程上执行合成动画操作。这样的效率是最高的，因为是在非主线程上合成，并没有占用主线程的资源，另外也避开了布局和绘制两个子阶段，所以相对于重绘和重排，合成能大大提升绘制效率。