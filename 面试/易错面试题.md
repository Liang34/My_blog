## 01

```js
var min = Math.min();
max = Math.max();
console.log(min < max);
// 写出执行结果，并解释原因
```

**答案**
false

**解析**

* 按常规的思路，这段代码应该输出 true，毕竟最小值小于最大值。但是却输出 false
* MDN 相关文档是这样解释的
  * Math.min 的参数是 0 个或者多个，如果多个参数很容易理解，返回参数中最小的。如果没有参数，则返回 Infinity，无穷大。
  * 而 Math.max 没有传递参数时返回的是-Infinity.所以输出 false

## 02

```js
var a = 1;
(function a() {
  a = 2;
  console.log(a);// 2
})();
```

答案：

```js
ƒ a() {
  a = 2;
  console.log(a)
}
```

原因：

作用域可以理解为执行上下文中申明的变量和作用的范围；包括块级作用域/函数作用域；

变量提升：一个声明在函数体内都是可见的，**函数声明优先于变量声明；**

在非匿名自执行函数中，函数变量为只读状态无法修改；


## 03

```js
var a = [0];
if (a) {
  console.log(a == true);
} else {
  console.log(a);
}
```

**答案**
false

**解析**
当 a 出现在 if 的条件中时，被转成布尔值，而 Boolean([0])为 true,所以就进行下一步判断 a == true,在进行比较时，[0]被转换成了 0，所以 0==true 为 false
数组从非 primitive 转为 primitive 的时候会先隐式调用 join 变成“0”，string 和 boolean 比较的时候，两个都先转为 number 类型再比较，最后就是 0==1 的比较了

## 04

```js
var company = {
    address: 'beijing'
}
var yideng = Object.create(company);
delete yideng.address
console.log(yideng.address);
// 写出执行结果，并解释原因
```

**答案**
beijing

**解析**
这里的 yideng 通过 prototype 继承了 company的 address。yideng自己并没有address属性。所以delete操作符的作用是无效的。

## 05 请问变量a会被GC吗

```js
function test(){
    var a = 1;
    return function(){
        eval("");
    }
}
test();
```

不会

因为eval会欺骗词法作用域，例如function test(){eval("var a = 1"},创建了一个a变量，不确定eval是否对a进行了引用，所以为了保险，不对其进行优化。相对，try catch,with也不会被回收，with会创建新的作用域。

## 06 写出执行结果,并解释原因

```js
var arr = [0, 1];
arr[5] = 5;
newArr = arr.filter(function (x) {
  return x === undefined;
});
console.log(newArr.length);
```

**答案**
0

**解析**

* `filter` 为数组中的每个元素调用一次 `callback` 函数，并利用所有使得 `callback` 返回 true 或[等价于 true 的值](https://developer.mozilla.org/zh-CN/docs/Glossary/Truthy)的元素创建一个新数组。`callback` 只会在已经赋值的索引上被调用，对于那些已经被删除或者从未被赋值的索引不会被调用。那些没有通过 `callback` 测试的元素会被跳过，不会被包含在新数组中。
* 也就是说 从 2-4 都是没有初始化的'坑'!, 这些索引并不存在与数组中. 在 array 的函数调用的时候是会跳过这些'坑'的.
